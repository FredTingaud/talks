<!DOCTYPE html>
<html>
  <head>
    <title>Quick Bench - A little order!</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
         font-family: 'Droid Serif';
         color: #ccc;
      }
      .remark-slide-content {
         background: #272822;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        font-size: 500%;
         color: #fff;
      }
      .remark-code, .remark-inline-code {
         font-family: 'Ubuntu Mono';
         font-size:100%;
         background-color: #373832 !important;
      }
      .remark-slide-content { font-size: 220%; }
      .remark-slide-content h1 { font-size: 250%; }
      .remark-slide-content h2 { font-size: 180%; }
      .remark-slide-content h3 { font-size: 180%; }
      .name {
        position:absolute;
        bottom: 80px;
        left: 50px;
        font-size: 100%;
        color: #bbb
      }
      .footnote {
        position:absolute;
        bottom: 80px;
        font-size: 80%;
        right: 3em;
        color: #bbb
      }
      .img-full-size img {
        width:100%;
      }
      .img-small-size img {
        width: 25%;
      }
      .gold {
        color: gold;
      }
      .version {
        color: LightSkyBlue;
      }
      .remark-code-line-highlighted {
        background-color: rgba(150, 130, 100, 0.5);
      }
      .remark-code-span-highlighted {
        background-color: rgba(150, 130, 100, 0.5);
        padding: 0px 2px 0px 2px;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center

--

# Previously

--

# on C++ FRUG's Lightning Talk

.img-small-size[![CPPFRUG Logo](img/Cpp-Francophonie.svg)]

---

## A micro-benchmarking online tool


.img-full-size[![Quick Bench interface](img/before.png)]

---

## A micro-benchmarking online tool


.img-full-size[![Quick Bench interface](img/after.png)]

---

## Google Benchmark

```C++
static void StringCopy(benchmark::State& state){
  std::string x = "hello";
  for (auto _ : state)
    std::string copy(x);
}
BENCHMARK(StringCopy);
```

---

## Google Benchmark

```C++
static void StringCopy(benchmark::State& state){
  std::string x(state.range(0), 'x');
  for (auto _ : state)
    std::string copy(x);
}
BENCHMARK(StringCopy)->Arg(1)->Arg(8)->Arg(1024);
```

---

## Google Benchmark

```C++
static void StringCopy(benchmark::State& state){
  std::string x(state.range(0), 'x');
  for (auto _ : state)
    std::string copy(x);
}
BENCHMARK(StringCopy)->Range(1, 1024);
```

---

http://quick-bench.com/AqJIRk1eCk4IX4hLLDfJ-uaPqMU

.img-full-size[![Copy by Size](img/copy-by-size.png)]

---

## A use case

Let's experiment on `<algorithm>` sorting tools by sorting all or part of a vector.

---

## Input

```C++
/**
 * returns a 1.000.000 elements std::vector<int>
 * generated by a Mersenne Twister random engine
 */
std::vector<int> getRandomVect();
```

---

## Sorted

```C++
static void sorted(benchmark::State& state) {
  auto input = getRandomVect();
  for (auto _ : state)
  {
    std::vector<int> values(input);
    std::sort(values.begin(), values.end());
  }
}
BENCHMARK(sorted);
```

---

## The Reference

```C++
static void unsorted(benchmark::State& state) {
  auto input = getRandomVect();
  for (auto _ : state)
  {
    std::vector<int> values(input);
    benchmark::DoNotOptimize(values);
  }
}
BENCHMARK(unsorted);
```

---

http://quick-bench.com/7QSvcyregOwAOpp3MEFdnvYyt_0

.img-full-size[![Sort result](img/sorted-result.png)]

---

## Now we can start comparing

`sort` VS `stable_sort`

---

http://quick-bench.com/dMAntsI0LNzurcC1qo8b9KcXlug

.img-full-size[![Stable sort result](img/stable-sorted-result.png)]

---

## Nth element

For a median calculation, we don't need to sort.

We can use `std::nth_element`.

.img[![Nth graph](img/nth1.svg)]

---

## Nth element

For a median calculation, we don't need to sort.

We can use `std::nth_element`.

.img[![Nth graph](img/nth2.svg)]

---

http://quick-bench.com/Sp7F2OELsI4X9bm9HEOH0IimWV4

.img-full-size[![Nth result](img/nth-element-result.png)]

nth_element is 10x faster than sort

---

## Partial sort

Another way to get the median is to use `std::partial_sort` and sort half of the elements.

.img[![partial graph](img/partial.svg)]

---

http://quick-bench.com/Svl-93AOl9J15Ai8zjNa-LCVFJM

.img-full-size[![Partial sort result](img/partial-sort-result.png)]

---
class: center, middle

# A Little Order!


.name[Fred Tingaud]
.footnote[&#x1F426 @FredTingaudDev]

---

## Home-cooked partial sort

What if we just call `std::sort` the result of nth_element?

It should do the same as `std::partial_sort`...

---

http://quick-bench.com/7d6eKuso1-i36VPp4fZ9qGvPtnQ

.img-full-size[![Home partial sort result](img/home-partial-sort-result.png)]

---

## Wait...

Am I smarter than the STL implementers?

--

Probably not

---

class: middle

## Let's read the contract again!

---

## Let's read the contract - Sort

Fine lines at the end of `std::sort` contract:

> **Complexity**
>
> `O(N·log(N))`, where N = std::distance(first, last) comparisons *on average*. .version[(until C++11)]
>
> `O(N·log(N))`, where N = std::distance(first, last) comparisons. .version[(since C++11)]

---

## Let's read the contract - Partial Sort

Fine lines at the end of `std::partial_sort` contract:

> **Complexity**
>
> Approximately (last-first)log(middle-first)) applications of cmp

---

## Let's read the contract - Partial Sort

Approximately (last-first)log(middle-first)) applications of cmp

`O(N·log(k))`, where N = std::distance(first, last) and k = std::distance(first, pos)

---

## Let's read the contract - Partial Sort

In our case, k = N / 2

`O(N·log(N / 2))`, where N = std::distance(first, last)

---

## Let's read the contract - Partial Sort

In our case, k = N / 2

`O(N·(log(N) - log(2))`, where N = std::distance(first, last)

---

## Let's read the contract - Partial Sort

In our case, k = N / 2

`O(N·log(N) - N·log(2))`, where N = std::distance(first, last)

---

## Let's read the contract - Partial Sort

In our case, k = N / 2

`O(N·log(N))`, where N = std::distance(first, last)

--

Just like `std::sort`

---

## Let's read the contract - Partial Sort

If we want to sort the 10 best scores in our MMO game.

k = 10

`O(N·log(10))`, where N = std::distance(first, last)

---

## Let's read the contract - Partial Sort

If we want to sort the 10 best scores in our MMO game.

k = 10

`O(N)`, where N = std::distance(first, last)

---

## Let's read the contract - Partial Sort

`O(N)`, now, THAT is a better complexity.

---

## Let's read the contract - Nth Element + Sort

The contract of Nth Element

`O(N)`, where N = std::distance(first, last) *on average*

So for the full algorithm

`O(N + M·log(k))`

---

## Let's read the contract - Nth Element + Sort

When k = N / 2

`O(N·log(N))`

When k = 10

`O(N)`

---

## T = f(N) | k = 100

```C++
static void partial_sorted(benchmark::State& state) {
  auto input = getRandomVect(state.range(0));
  while (state.KeepRunning())
  {
    std::vector<int> values(input);
    auto middle = values.begin() + 100;
    std::partial_sort(values.begin(), middle, values.end());
  }
}
BENCHMARK(partial_sorted)->Arg(100)->Arg(100000)->Arg(500000)->Arg(1000000);
```

---

## T = f(N) | k = 100

.img-full-size[![k = 100](img/M_100.png)]

---

## T = f(N) | k = N / 5

```C++
static void partial_sorted(benchmark::State& state) {
  auto input = getRandomVect(state.range(0));
  while (state.KeepRunning())
  {
    std::vector<int> values(input);
    auto middle = values.begin() + 0.2*state.range(0);
    std::partial_sort(values.begin(), middle, values.end());
  }
}
BENCHMARK(partial_sorted)->Arg(100)->Arg(100000)->Arg(500000)->Arg(1000000);
```

---

## T = f(N) | k = N / 5

.img-full-size[![k = N / 5 ](img/M_N_by_5.png)]

---

## T = f(k) | N = 1,000,000

```C++
static void partial_sorted(benchmark::State& state) {
  auto input = getRandomVect(1'000'000);
  while (state.KeepRunning())
  {
    std::vector<int> values(input);
    auto middle = values.begin() + state.range(0);
    std::partial_sort(values.begin(), middle, values.end());
  }
}
BENCHMARK(partial_sorted)->Arg(3)->Arg(100)->Arg(1000)->Arg(SIZE/4)->Arg(SIZE/2)->Arg(SIZE);
```

---

## T = f(k) | N = 1,000,000

.img-full-size[![Algorithm by k](img/whole-range.png)]

---

## T = f(k) | N = 1,000,000 - Zoomed

.img-full-size[![Algorithm by k](img/zoomed-range.png)]

---

## When to use `std::partial_sort`

*Use `partial_sort` when sorting for a constant number of elements that is considerably smaller than the total size of the array*.

*Prefer `nth_element + sort` if the number of elements grows with the array or is near the array size.*

---

## How? Why?

How is it faster than nth_element for lower values of k?

Why is it slower for higher values?

---

class: middle

## Let's review some famous algorithms

---

class: middle

## Insertion Sort

---

## Insertion Sort

.img[![Insertion Sort](img/empty.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion0.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion1.5.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion1.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion2.5.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion2.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion4.5.svg)]


---

## Insertion Sort

.img[![Insertion Sort](img/insertion3.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion3.5.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion4.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion5.5.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion5.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion6.svg)]

---

## Insertion Sort

.img[![Insertion Sort](img/insertion7.svg)]

---

## Insertion Sort

* `O(n²)`

* Negligeable memory consumption

---

class: middle

## Quicksort

---

## Quicksort

.img[![Quicksort](img/empty.svg)]

---

## Quicksort

.img[![Quicksort](img/qs1.svg)]

---

## Quicksort

.img[![Quicksort](img/qs2.svg)]

---

## Quicksort

.img[![Quicksort](img/qs3.svg)]

---

## Quicksort

.img[![Quicksort](img/qs4.svg)]

---

## Quicksort

* `O(N·log(N))` *on average*

* Quick

* Negligeable memory consumption

--

* `O(N²)` on worst case scenario

---

## Quicksort

3 strategies for pivot selection:

* Median of 3

--

* Random value

--

* Median of medians

---

## Quicksort

.img-full-size[![Quicksort pivots](img/pivot-lol.png)]

---

## Quicksort

.img-full-size[![Quicksort pivots](img/pivot-serious.png)]

---

class: middle

## Heapsort

---

## Heap - Insert

.img[![Heapsort](img/heap1.svg)]

---

## Heap - Insert

.img[![Heapsort](img/heap2.svg)]

---

## Heap - Insert

.img[![Heapsort](img/heap3.svg)]

---

## Heap - Insert

.img[![Heapsort](img/heap4.svg)]

---

## Heap - Extract

.img[![Heapsort](img/heap5.svg)]

---

## Heap - Extract

.img[![Heapsort](img/heap6.svg)]

---

## Heap - Extract

.img[![Heapsort](img/heap7.svg)]

---

## Heap - Extract

.img[![Heapsort](img/heap8.svg)]

---

## Heap - Array

.img[![Heapsort](img/heap-array.svg)]

---

## Heapsort

* We build a heap tree inside the container to sort.

* Then we extract elements one by one and put them back in the position freed by the heap.

---

## Heapsort

* `O(N·log(N))`

* 4 to 5 times slower than quick-sort

* Negligeable memory consumption

---

class:middle

## RTFSC!

## Read The *Fantastic* Source Code!


---

class:middle

## `std::sort`

---

## GCC implementation

```C++
template<typename _RandomAccessIterator, typename _Compare>
  inline void
  sort(_RandomAccessIterator first, _RandomAccessIterator last,
         _Compare comp) {
  if (first != last){
    std::__introsort_loop(first, last,
                          std::__lg(last-first)*2,
                          comp);
    std::__final_insertion_sort(first, last, comp);
  }
}
```

---

## Introsort

> **Complexity**
>
> `O(N·log(N))`, where N = std::distance(first, last) comparisons *on average*. .version[(until C++11)]
>
> `O(N·log(N))`, where N = std::distance(first, last) comparisons. .version[(since C++11)]

---

## Introsort

* Quicksort does not respect the `std::sort` contract in worst case scenario.

* Heapsort is slower for standard scenario.

--

Let's do BOTH!

---

## Introsort

Quicksort recurses on `2 * log(N)` levels max

Then Heapsort is called on the rest in case it's still not sorted

`O(N·log(N))` in all cases

---

## GCC implementation

```C++
template<typename _RandomAccessIterator, typename _Compare>
  inline void
  sort(_RandomAccessIterator first, _RandomAccessIterator last,
         _Compare comp) {
  if (first != last){
    std::__introsort_loop(first, last,
                          std::__lg(last-first)*2,
                          comp);
    std::__final_insertion_sort(first, last, comp);
  }
}
```

---

## Final Insertion Sort

On small distances, insertion sort performs better than Quicksort.

We sort up to a fixed small size k.

Insertion sort is then `O(k·N)`.

---

class: middle

## `std::nth_element`

---

## Nth Element

> **Complexity**
>
> `O(N)`, where N = std::distance(first, last) *on average*

---

## Quickselect

Simplified Quicksort

We choose a pivot and we partition like Quicksort.

--

If the pivot ends up at nth position, we are finished.

--

Otherwise, we recurse only on the side that contains nth position.

---

## GCC Implementation

```C++
template<typename _RandomAccessIterator>
  inline void
  nth_element(_RandomAccessIterator first, _RandomAccessIterator nth,
              _RandomAccessIterator last)
{
  if (first == last || nth == last)
    return;

  std::__introselect(first, nth, last,
                     std::__lg(last - first) * 2,
                     __gnu_cxx::__ops::__iter_less_iter());
}
```

---

## Introselect

* Up to `2 * log(N)` recursions.

* Then Heapselect.

---

## Heapselect

We create a heap on n elements with fast access to max.

--

We iterate on all other elements.

--

If an element is smaller than heap max, we pop the heap and add the new element.

--

Heap max is the nth element at the end.

---

## Heapselect

* O(N·log(k))

* Negligeable memory consumption.

---

class: middle

## `std::partial_sort`

---

## GCC Implementation

```C++
template<typename _RandomAccessIterator, typename _Compare>
  inline void
  __partial_sort(_RandomAccessIterator first,
                 _RandomAccessIterator middle,
                 _RandomAccessIterator last,
                 _Compare comp)
{
   std::__heap_select(first, middle, last, comp);
   std::__sort_heap(first, middle, comp);
}
```

---

## Partial sort

We said that heapsort was slower than quicksort

heapselect is `O(N·log(k))` when quickselect is `O(N)`

Yet partial_sort can perform better than quickselect + quicksort?!

---

## Heapselect benchmark

```C++
static void heap_select(benchmark::State& state) {
  auto input = getRandomVect();
  while (state.KeepRunning())
  {
    std::vector<int> values(input);
    auto middle = values.begin() + state.range(0);
    std::__heap_select(values.begin(), middle, values.end()
        , __gnu_cxx::__ops::__iter_less_iter());
  }
}
BENCHMARK(heap_select)->Arg(3)->Arg(5000)->Arg(10000)->Arg(20000)->Arg(40000);
```

---

## Heapselect benchmark

.img-full-size[![Heapselect](img/heap-select.png)]

---

## Partial sort

* Heapselect performs better with low `k` value

* Its performance decreases with the value of `k`

---

class: middle

## Context of usage

---

## Nth element

Nth element is used for every value of `k`.

It can be to get a decile, or a median.

The STL implementers went for a `O(N)` algorithm that behaves independantly from `k`.

---

## Partial Sort

The typical usage of `std::partial_sort` is to sort a small subset of elements in a big array.

The STL implementers went for a faster `O(N·log(k))` algorithm that performs well for this typical use-case at the expense of other scenarios.

---

class: middle

Despite the genericity of the STL, some choices have to be made.

In this case, algorithms are tuned for their typical use cases.

---

class: middle

The STL implementers knew what they were doing!

And now we do too!

---

class: center, middle

# Please go on
# `quick-bench.com`
# and fiddle with it!

.name[Fred Tingaud]
.footnote[&#x1F426 @FredTingaudDev]


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
          ratio: '16:9',
          highlightStyle: 'monokai',
          highlightLanguage: 'C++',
          highlightLines: true,
          highlightSpans: true
        });
    </script>
  </body>
</html>
