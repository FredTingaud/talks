<!DOCTYPE html>
<html>
  <head>
    <title>R-Values</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
         font-family: 'Droid Serif';
         color: #ccc;
      }
      .remark-slide-content {
         background: #272822;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        font-size: 500%;
         color: #fff;
      }
      .remark-code, .remark-inline-code {
         font-family: 'Ubuntu Mono';
         font-size:100%;
         background-color: #373832 !important;
      }
      .remark-slide-content { font-size: 180%; }
      .remark-slide-content h1 { font-size: 250%; }
      .remark-slide-content h2 { font-size: 180%; }
      .remark-slide-content h3 { font-size: 180%; }
      .name {
        position:absolute;
        bottom: 80px;
        left: 50px;
        font-size: 100%;
        color: #bbb
      }
      .footnote {
        position:absolute;
        bottom: 80px;
        font-size: 80%;
        right: 3em;
        color: #bbb
      }
      .move {
         color: rgb(249, 38, 114);
         font-size: 100%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# = R-Values

### .move[<sub>&#9834;</sub>   I like to move it   <sup>&#9835;</sup>]

.name[Fred Tingaud]
.footnote[&#x1F426 @FredTingaudDev]

---

## A short lived praise


```C++
std::string getPraise()
{
   return "What a great talk!" ;
}
int main()
{
   const char* praise = getPraise().c_str();
   std::cout << praise << "\n" ;
}
```

---

## Temporary Variables


* This kind of variables have been called *temporary* variables.

--

* They have no name, so they cannot be re-used.

--

* They have existed since C.

--

* They were sometimes already elided by the compiler to optimize compiled code (RVO).

---

## R-Values

--

* In C++11, an expression generating a temporary is called an *r-value* (right).

--

* This characteristic can be harvested to optimize the code generated by a compiler.

--

* A named expression is an *l-value* (left).

---

## R-Value References

```C++
int&& x
```

* This **&&** notation is an **r-value reference**.

--

* R-value references only accept r-values.

--

* R-value references are named. They are **l-values** themselves.

---

## Using R-Values

--

An r-value will never be used again, we can salvage it!

```C++
   struct A {
      B* b_;

      A() : b_(new B()) {}
      ~A() {if (b_) delete b_;}

      A(A const & other) : b_(new B(other.b_)) {}
      A(A&& other) : b_(other.b_) {
         other.b_ = nullptr;
      }
   };
```

---

## Hands-up

Our hands-up context:

```C++
#include <iostream>
using namespace std;

void foo(const int& x) { cout << "Ohh :("; }
void foo(int&& x) { cout << "Ahh :)"; }
```

---

## Hands-up

.footnote[http://ideone.com/zuNpXd]

```C++
   foo(5);
```

--

Ahh :)

---

## Hands-up

.footnote[http://ideone.com/BrYeEf]

```C++
   int i = 5;
   foo(i);
```

--

Ohh :(

---

## Hands-up

.footnote[http://ideone.com/iZ3G1X]

```C++
   int&& i = 5;
   foo(i);
```

--

Ohh :(

---

## Hands-up

.footnote[http://ideone.com/WCOPXS]

```C++
   int&& i = 5;
   foo(i + 1);
```

--

Ahh :)

---

## What have we learned so far?

r-value references **bind** to r-values.

They don't create them.

---

## Recycling to an r-value

```C++
   foo(1 + 4 * 12 - 41);
```

--

Used to be made more readable by adding an intermediary variable.

```C++
   int magicNumber = 1 + 4 * 12 - 41;
   foo(magicNumber);
```

--

Are we doomed now?

---

## Recycling to an r-value

--

.footnote[http://ideone.com/eaA7ma]

```C++
   int i = 5;
   foo(static_cast<int&&>(i));
```

--

Ahh :)

---

## Recycling to an r-value

C++11 also provides an alias for this cast.

```C++
   std::move(i);
```

--

It doesn't do anything more!

--

It doesn't move!

--

```C++
   std::move(i) &cong; static_cast<int&&>(i)
```

---

## Recycling to an r-value

.footnote[http://ideone.com/4fZq79]

```C++
   int i = 5;
   foo(std::move(i));
```

--

Ahh :)

---

## Recycling to an r-value

.footnote[http://ideone.com/xMQwyg]

```C++
   int i = 5;
   foo(std::move(i) + 1);
```

--

Ahh :)

---

## Recycling to an r-value

.footnote[http://ideone.com/cQdcZB]

```C++
   const int i = 5;
   foo(std::move(i));
```

--

Ohh :(

---

## Passing an r-value

Let's create a method that passes its parameter to foo...

---

## Passing an r-value

.footnote[http://ideone.com/Zqhkqt]

```C++
void pass(int&& x) {
   foo(x);
}
int main()
{
   pass(5);
}
```

--

Ohh :(

---

## Passing an r-value

.footnote[http://ideone.com/BEA1Sq]

```C++
void pass(int&& x) {
   foo(std::move(x));
}
int main()
{
   pass(5);
}
```

--

Ahh :)

---

## Passing an l-value

.footnote[http://ideone.com/Q85J7G]

```C++
void pass(int&& x) {
   foo(std::move(x));
}
int main()
{
   int i = 5;
   pass(i);
}
```

--

(╯°□°）╯︵ ┻━┻<br>
error: cannot bind 'int' lvalue to 'int&&'

---

## Passing an l-value

.footnote[http://ideone.com/Gb3gAh]

```C++
void pass(const int& x) {
   foo(x);
}
int main()
{
   int i = 5;
   pass(i);
}
```

--

Ohh :(

---

## Passing both l-values and r-values

.footnote[http://ideone.com/WfWCHE]

```C++
void pass(const int& x) {
   foo(x);
}
void pass(int&& x) {
   foo(std::move(x));
}
int main()
{
   int i = 5;
   pass(i);
   pass(5);
}
```

--

Ohh :(Ahh :)

---

## Passing both l-values and r-values

Two methods is manageable, but what if we want to have more than one parameter?

--

```C++
void pass(const int& x, const int& y);
void pass(int&& x, const int& y);
void pass(const int& x, int&& y);
void pass(int&& x, int&& y);
```

---

## Passing both l-values and r-values

```C++
void pass(const int& x, const int& y, const int& z);
void pass(int&& x, const int& y, const int& z);
void pass(const int& x, int&& y, const int& z);
void pass(int&& x, int&& y, const int& z);
void pass(const int& x, const int& y, int&& z);
void pass(int&& x, const int& y, int&& z);
void pass(const int& x, int&& y, int&& z);
void pass(int&& x, int&& y, int&& z);
```

---

## Passing both l-values and r-values

We need 2<sup>n</sup> methods to cover all cases.

*It doesn't scale!*

---

## Passing both l-values and r-values

```C++
template<typename T>
void pass(T&& x)
```

This is a **forwarding reference**.

--

It can either take an r-value or an l-value.

--

Contrary to `void pass(int x)`, it does no implicit conversion on the value.



---

## Passing both l-values and r-values

.footnote[http://ideone.com/9ZRd1c]

```C++
template<typename T>
void pass(T&& x) {
   foo(x);
}
int main()
{
   int i = 5;
   pass(i);
   pass(5);
}
```

--

Ohh :(Ohh :(

---

## Passing both l-values and r-values

.footnote[http://ideone.com/otJKIM]

```C++
template<typename T>
void pass(T&& x) {
   foo(std::move(x));
}
int main()
{
   int i = 5;
   pass(i);
   pass(5);
}
```

--

Ahh :)Ahh :)

---

## Passing both l-values and r-values

.footnote[http://ideone.com/GmzRlb]

```C++
template<typename T>
void pass(T&& x) {
   foo(std::move(x));
}
int main()
{
   const int i = 5;
   pass(i);
   pass(5);
}
```

--

Ohh :(Ahh :)

---

## Passing both l-values and r-values

None of those codes were satisfactory.

--

It is great to bind to both r-values and l-values, but we need to treat them *differently* afterward.

r-values should be **moved**.

l-values should be **passed** as references.

---

## Passing both l-values and r-values


```C++
template<typename T>
void pass(T&& x)
{
   std::forward<T>(x);
}
```

--

This call will do exactly what we want.

It will move the r-values and pass the l-values as expected.

---

## Passing both l-values and r-values

.footnote[http://ideone.com/Gj3Py5]

```C++
template<typename T>
void pass(T&& x) {
   foo(std::forward<T>(x));
}
int main()
{
   int i = 5;
   pass(i);
   pass(5);
}
```

--

Ohh :(Ahh :)

---

## What we've seen

* R-Values are expression returning a temporary.

* We can use this to make destructive optimizations.

---

## What we've seen

* **R-Value references** (int&&) only bind to r-values.

* **R-Value references** are not r-values.

---

## What we've seen

* `std::move` casts to r-value reference.

---

## What we've seen

* `template<typename T> void pass(T&& t)` is a **forwarding reference**

* It doesn't lose the R-Value/L-Value information

* `std::forward<T>` **forwards** this information farther

---

class: center, middle

# Now start .move[std::moving]!

.name[Fred Tingaud]
.footnote[&#x1F426 @FredTingaudDev]

---

class: center, middle

# Questions?

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'C++',
          highlightLines: true
        });
    </script>
  </body>
</html>
